{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Le Jeu de la Vie - Impl\u00e9mentation C++ Moderne","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Une impl\u00e9mentation moderne et interactive du c\u00e9l\u00e8bre automate cellulaire de John Conway, offrant une exp\u00e9rience utilisateur riche \u00e0 travers des interfaces graphique et console.</p>"},{"location":"#caracteristiques-principales","title":"Caract\u00e9ristiques Principales","text":""},{"location":"#modes-daffichage","title":"Modes d'Affichage","text":"<ul> <li>\ud83c\udfae Interface graphique SFML avec rendu en temps r\u00e9el</li> <li>\ud83d\udcbb Mode console avec repr\u00e9sentation ASCII color\u00e9e</li> <li>\ud83d\udd04 Transition fluide entre les modes</li> </ul>"},{"location":"#simulation-avancee","title":"Simulation Avanc\u00e9e","text":"<ul> <li>\ud83c\udfaf Contr\u00f4le pr\u00e9cis de la vitesse de simulation</li> <li>\ud83c\udf0d Mode toro\u00efdal pour grille infinie</li> <li>\ud83d\udea7 Support des obstacles statiques</li> <li>\ud83d\udcca Suivi en temps r\u00e9el de l'\u00e9volution</li> </ul>"},{"location":"#patterns-predefinis","title":"Patterns Pr\u00e9d\u00e9finis","text":"<ul> <li>\ud83d\ude80 Glider - Structure mobile classique</li> <li>\ud83c\udfed Glider Gun - G\u00e9n\u00e9rateur de gliders</li> <li>\ud83d\udd04 Oscillateurs - Structures p\u00e9riodiques</li> <li>\ud83d\udef8 Vaisseaux - Structures mobiles complexes</li> <li>\u26a1 Patterns stables et m\u00e9tastables</li> </ul>"},{"location":"#personnalisation","title":"Personnalisation","text":"<ul> <li>\u2699\ufe0f Configuration flexible des r\u00e8gles d'\u00e9volution</li> <li>\ud83c\udfa8 Personnalisation des couleurs et de l'affichage</li> <li>\ud83d\udcd0 Taille de grille adaptable</li> <li>\u23f1\ufe0f Ajustement dynamique de la vitesse</li> </ul>"},{"location":"#demarrage-rapide","title":"D\u00e9marrage Rapide","text":"<pre><code>git clone https://github.com/ctrl-hexa/game-of-life.git\ncd game-of-life\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n./game_of_life\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Pour plus de d\u00e9tails sur : * \ud83d\udcd6 L'architecture du projet * \ud83d\udee0\ufe0f Les outils de d\u00e9veloppement * \ud83e\uddea La suite de tests * \ud83d\udd27 Les options de configuration</p> <p>Consultez les sections d\u00e9di\u00e9es dans la documentation.</p>"},{"location":"#contribution","title":"Contribution","text":"<p>Nous accueillons les contributions ! Consultez notre guide de contribution pour plus d'informations.</p>"},{"location":"quickstart/","title":"Guide de D\u00e9marrage Rapide","text":""},{"location":"quickstart/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>\ud83d\udd27 Compilateur C++ (GCC 7+ ou \u00e9quivalent)</li> <li>\ud83d\udce6 CMake 3.10 ou sup\u00e9rieur</li> <li>\ud83c\udfae SFML 2.5+ pour l'interface graphique</li> <li>\ud83d\udc27 Linux/MacOS ou Windows avec MSYS2</li> </ul>"},{"location":"quickstart/#installation-en-5-minutes","title":"Installation en 5 Minutes","text":""},{"location":"quickstart/#1-cloner-le-projet","title":"1. Cloner le Projet","text":"<pre><code>git clone https://github.com/ctrl-hexa/game-of-life.git\ncd game-of-life\n</code></pre>"},{"location":"quickstart/#2-compiler","title":"2. Compiler","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\n</code></pre>"},{"location":"quickstart/#3-lancer-le-jeu","title":"3. Lancer le Jeu","text":"<pre><code>./game_of_life\n</code></pre>"},{"location":"quickstart/#configuration-rapide","title":"Configuration Rapide","text":""},{"location":"quickstart/#mode-de-jeu","title":"Mode de Jeu","text":"<ol> <li>Choisir le mode de chargement :</li> <li><code>y</code> : Charger un pattern pr\u00e9d\u00e9fini</li> <li><code>n</code> : Cr\u00e9er une grille al\u00e9atoire</li> </ol>"},{"location":"quickstart/#parametres-essentiels","title":"Param\u00e8tres Essentiels","text":"<ul> <li>Taille de grille : 1-300 (recommand\u00e9 : 50x50)</li> <li>Vitesse : 1-1000ms (recommand\u00e9 : 100ms)</li> <li>Mode d'affichage : Console ou Graphique</li> <li>R\u00e8gles : Classic ou HighLife</li> </ul>"},{"location":"quickstart/#commandes-de-base","title":"Commandes de Base","text":"<ul> <li>\ud83d\udd04 Red\u00e9marrer : Relancer l'application</li> <li>\u23f9\ufe0f Arr\u00eater : Attendre la fin ou Ctrl+C</li> <li>\ud83d\udcbe Sauvegarder : Automatique dans <code>assets/saved-games/</code></li> </ul>"},{"location":"quickstart/#patterns-recommandes","title":"Patterns Recommand\u00e9s","text":"<ul> <li>D\u00e9butant : <code>stable</code>, <code>oscillator</code></li> <li>Interm\u00e9diaire : <code>glider</code>, <code>spaceship</code></li> <li>Avanc\u00e9 : <code>glider-gun</code></li> </ul>"},{"location":"quickstart/#problemes-courants","title":"Probl\u00e8mes Courants","text":"<ul> <li>Erreur SFML : V\u00e9rifier l'installation de la biblioth\u00e8que</li> <li>Erreur de compilation : V\u00e9rifier la version de CMake</li> <li>Crash au lancement : V\u00e9rifier les droits d'acc\u00e8s aux fichiers</li> </ul>"},{"location":"quickstart/#ressources","title":"Ressources","text":"<ul> <li>\ud83d\udcd6 Documentation compl\u00e8te : <code>docs/</code></li> <li>\ud83d\udc1b Rapport de bugs : GitHub Issues</li> <li>\ud83d\udcac Support : Discord</li> </ul>"},{"location":"guide_utilisateur/installation/","title":"Guide d'Installation et d'Utilisation du Jeu de la Vie","text":""},{"location":"guide_utilisateur/installation/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Un compilateur C++ (GCC recommand\u00e9)</li> <li>CMake (version 3.10 minimum)</li> <li>La biblioth\u00e8que SFML pour le rendu graphique</li> </ul>"},{"location":"guide_utilisateur/installation/#installation","title":"Installation","text":"<ol> <li>Cloner le d\u00e9p\u00f4t: <code>git clone https://github.com/ctrl-hexa/game-of-life.git &amp;&amp; cd game-of-life</code></li> <li>Installer SFML:</li> <li>Windows (MSYS2): <code>pacman -S mingw-w64-x86_64-sfml</code></li> <li>Linux: <code>sudo apt-get install libsfml-dev</code></li> <li>Compiler: <code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make</code></li> </ol>"},{"location":"guide_utilisateur/installation/#utilisation","title":"Utilisation","text":"<ol> <li>Lancer: <code>./game_of_life</code></li> <li>Choisir le mode de chargement (y: fichier, n: al\u00e9atoire)</li> <li>Si fichier: choisir un pattern (0-5)</li> <li>0: Dying</li> <li>1: Glider Gun</li> <li>2: Glider</li> <li>3: Oscillator</li> <li>4: Spaceship</li> <li>5: Stable</li> <li>Si al\u00e9atoire:</li> <li>Largeur (1-300)</li> <li>Hauteur (1-300)</li> <li>Configuration:</li> <li>Grille toro\u00efdale (y/n)</li> <li>Strat\u00e9gie (0: Classic, 1: HighLife)</li> <li>Rendu (0: Console, 1: Graphique)</li> <li>Nombre d'it\u00e9rations (1-1000000)</li> <li>D\u00e9lai entre it\u00e9rations en ms (0-1000000)</li> </ol>"},{"location":"guide_utilisateur/installation/#format-fichier-grille","title":"Format Fichier Grille","text":"<ul> <li>Ligne 1: <code>largeur hauteur</code></li> <li>Lignes suivantes: matrice (0: mort, 1: vivant, X: obstacle)</li> </ul> <p>Note: Le jeu s'arr\u00eate si la grille est stable ou nombre max d'it\u00e9rations atteint. Sauvegardes dans <code>assets/saved-games/</code></p>"},{"location":"guide_utilisateur/utilisation/interface/","title":"Interfaces Utilisateur du Jeu de la Vie","text":""},{"location":"guide_utilisateur/utilisation/interface/#interface-console","title":"Interface Console","text":"<ul> <li>Affichage en ASCII avec codes couleur:</li> <li><code>0</code> (blanc): Cellule morte</li> <li><code>1</code> (vert): Cellule vivante</li> <li><code>X</code> (rouge): Obstacle</li> <li>Rafra\u00eechissement automatique de l'\u00e9cran \u00e0 chaque it\u00e9ration</li> <li>Affichage des messages de statut (Game Over, Stable Grid, etc.)</li> </ul>"},{"location":"guide_utilisateur/utilisation/interface/#interface-graphique-sfml","title":"Interface Graphique (SFML)","text":"<ul> <li>Fen\u00eatre de 800x600 pixels</li> <li>Repr\u00e9sentation des cellules:</li> <li>Noir: Cellule morte</li> <li>Vert: Cellule vivante</li> <li>Rouge: Obstacle</li> <li>Grille dynamique s'adaptant \u00e0 la taille de la fen\u00eatre</li> <li>Affichage en temps r\u00e9el des changements</li> </ul>"},{"location":"guide_utilisateur/utilisation/interface/#interface-de-configuration-console","title":"Interface de Configuration (Console)","text":"<ol> <li>Menu Principal</li> <li>Choix du mode de chargement</li> <li>S\u00e9lection des fichiers de pattern</li> <li> <p>Configuration de la taille de grille</p> </li> <li> <p>Param\u00e8tres de Simulation</p> </li> <li>Mode toro\u00efdal (grille cyclique)</li> <li>Choix de la strat\u00e9gie d'\u00e9volution</li> <li>Configuration de la vitesse</li> <li> <p>Nombre d'it\u00e9rations maximum</p> </li> <li> <p>Messages Syst\u00e8me</p> </li> <li>Erreurs de fichier</li> <li>\u00c9tat de la simulation</li> <li>Conditions d'arr\u00eat</li> </ol>"},{"location":"guide_utilisateur/utilisation/interface/#sauvegarde","title":"Sauvegarde","text":"<ul> <li>Sauvegarde automatique de l'\u00e9tat final</li> <li>Format texte lisible et modifiable</li> <li>Stockage dans <code>assets/saved-games/</code></li> </ul>"},{"location":"technique/diagrammes/","title":"Diagrammes UML du Projet","text":""},{"location":"technique/diagrammes/#1-diagramme-de-cas-dutilisation","title":"1. Diagramme de Cas d'Utilisation","text":"<p><pre><code>graph TD\n    User((Utilisateur))\n\n    subgraph \"Jeu de la Vie\"\n        A[D\u00e9marrer simulation]\n        B[Modifier cellules]\n        C[Charger motif]\n        D[Sauvegarder \u00e9tat]\n        E[Ajuster vitesse]\n        F[Changer mode]\n    end\n\n    User --&gt; A\n    User --&gt; B\n    User --&gt; C\n    User --&gt; D\n    User --&gt; E\n    User --&gt; F</code></pre> Ce diagramme refl\u00e8te les interactions utilisateur impl\u00e9ment\u00e9es dans la classe <code>Game</code> et <code>Config</code> : * Configuration du jeu (m\u00e9thode <code>Config::setup()</code>) * Lancement d'une partie (<code>Game::run()</code>) * Visualisation de l'\u00e9volution (via <code>IRenderer::render()</code>) * Sauvegarde/Chargement (via <code>FileHandler</code>) * Gestion des patterns pr\u00e9d\u00e9finis</p>"},{"location":"technique/diagrammes/#2-diagramme-de-classes","title":"2. Diagramme de Classes","text":"<p><pre><code>classDiagram\n    class Game {\n        - Config config\n        - Grid *grid\n        - IRenderer *renderer\n        - IEvolutionStrategy *evolutionStrategy\n        - int iterationDelay\n        - int numberOfIterations\n        + Game()\n        + void run()\n        + void setup()\n        + setters()\n        + getters()\n        + ~Game()\n    }\n\n    class Grid {\n        - std::vector&lt;std::vector&lt;Cell&gt;&gt; cells\n        - int width\n        - int height\n        - bool isToroidal\n        + Grid(int width, int height)\n        + void initCells(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;tab)\n        + void initCellsRandom()\n        + bool calculateNextGen(IEvolutionStrategy *evolutionStrategy)\n        + int countLiveNeighbors(int x, int y)\n        + void printCells() const\n        + bool isGridStable(const std::vector&lt;std::vector&lt;CellType&gt;&gt;&amp; nextGen) const\n        + getters()\n        + setters()\n        + ~Grid()\n    }\n\n    class Cell {\n        - CellType type\n        + Cell()\n        + Cell(CellType type)\n        + CellType getType() const\n        + void setType(CellType newType)\n        + ~Cell()\n    }\n\n    class CellType {\n        &lt;&lt;enumeration&gt;&gt;\n        Alive\n        Dead\n        Obstacle\n    }\n\n    class Config {\n        - map&lt;inputType, string&gt; questions\n        - map&lt;inputType, vector&lt;string&gt;&gt; validResponses\n        - unique_ptr&lt;InputHandler&gt; inputHandler\n        + Config()\n        + void setup(Game* game)\n        + T getInput(inputType type, const T&amp; defaultValue)\n        + string inputLoadChoice()\n        + string inputFilename()\n        + GridData inputGridData()\n        + bool inputGridToroidal()\n        + string inputEvolutionStrategy()\n        + string inputRenderer()\n        + int inputIterationNumber()\n        + int inputIterationDelay()\n        + ~Config()\n    }\n\n    class InputHandler {\n        + ~InputHandler()\n        + template&lt;T&gt; T handleInput(const string&amp; question, const T&amp; defaultValue, vector&lt;T&gt; validResponses, inputType inputType)\n    }\n\n    class IEvolutionStrategy {\n        + bool evolve(Cell* cell, int liveNeighbors) const = 0\n        + string getName() const = 0\n        + ~IEvolutionStrategy() = default\n    }\n\n    class ClassicEvolution {\n        - string name = \"Classic\"\n        + ClassicEvolution()\n        + bool evolve(Cell* cell, int liveNeighbors) const override\n        + string getName() const override\n        + ~ClassicEvolution() override\n    }\n\n    class HighLifeEvolution {\n        - string name = \"High Life\"\n        + HighLifeEvolution()\n        + bool evolve(Cell* cell, int liveNeighbors) const override\n        + string getName() const override\n        + ~HighLifeEvolution() override\n    }\n\n    class Subject {\n        - std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; observers\n        + void attach(std::shared_ptr&lt;Observer&gt; observer)\n        + void detach(std::shared_ptr&lt;Observer&gt; observer)\n        + void notify()\n        + ~Subject()\n    }\n\n    class Observer {\n        + void update(Subject* subject) = 0\n        + ~Observer()\n    }\n\n    class IRenderer {\n        + void render(Grid* grid)\n        + string getName() const\n        + void update(Subject *subject)\n        + ~IRenderer()\n    }\n\n    class ConsoleRenderer {\n        + ConsoleRenderer()\n        + void render(Grid* grid) override\n        + string getName() const override\n        + ~ConsoleRenderer() override\n    }\n\n    class GraphicRenderer {\n        - sf::RenderWindow window\n        - sf::Font font\n        - std::vector&lt;sf::Text&gt; configTexts\n        - sf::Text inputText\n        - std::string currentInput\n        - bool waitingForInput\n        + GraphicRenderer()\n        + void render(Grid* grid) override\n        + sf::RenderWindow&amp; getWindow()\n        + string getName() const override\n        + ~GraphicRenderer() override\n    }\n\n    class FileHandler {\n        + FileHandler()\n        + GridDimensions loadDimensions(string filename)\n        + vector&lt;vector&lt;int&gt;&gt; loadInputFromFile(string filename)\n        + void saveGridToFile(Grid* grid)\n        + void update(Subject* subject) override\n        + ~FileHandler()\n    }\n\n    IRenderer &lt;|-- GraphicRenderer  : inherits\n    IRenderer &lt;|-- ConsoleRenderer : inherits\n\n    IEvolutionStrategy &lt;|-- ClassicEvolution : inherits\n    IEvolutionStrategy &lt;|-- HighLifeEvolution : inherits\n\n    Game --&gt; Grid : uses\n    Game --&gt; IRenderer : uses\n    Game --&gt; IEvolutionStrategy : uses\n    Game --&gt; FileHandler : uses\n    Game --&gt; Config : uses\n\n    Config --&gt; InputHandler : uses\n\n    Grid --&gt; Cell : uses\n\n    Cell --&gt; CellType : uses\n\n    Subject  &lt;|-- Game : inherits\n    Observer &lt;|-- IRenderer : inherits\n    Observer &lt;|-- FileHandler : inherits</code></pre> La structure refl\u00e8te l'impl\u00e9mentation actuelle avec : * Pattern Observer : <code>Subject</code>, <code>Observer</code>, <code>IRenderer</code> * Pattern Strategy : <code>IEvolutionStrategy</code>, <code>ClassicEvolution</code>, <code>HighLifeEvolution</code> * Core : <code>Game</code>, <code>Grid</code>, <code>Cell</code> * IO : <code>FileHandler</code>, <code>Config</code>, <code>InputHandler</code></p>"},{"location":"technique/diagrammes/#3-diagramme-de-sequence","title":"3. Diagramme de S\u00e9quence","text":"<p><pre><code>---\nconfig:\n  theme: neutral\n---\nsequenceDiagram\n\n  User -&gt;&gt; Programme: Lancer le programme\n  Programme -&gt;&gt; Game: Instancie game\n  Programme -&gt;&gt; Game: Game.setup()\n  Game -&gt;&gt; Config: Config.setup(this)\n  Config -&gt;&gt; User: Demande la config\n  User --&gt;&gt; Config: Entre la config\n  alt User joue a partir d'un fichier\n    Config -&gt;&gt; FileHandler: loadGridFromFile()\n    FileHandler --&gt;&gt; Config: return vector des 1 et 0\n    Config -&gt;&gt; Grid: Grid.initCells()\n  end\n  alt User joue a partir d'une nouvelle partie\n    Config -&gt;&gt; Grid: Grid.initCellsRandom()\n  end\n  Grid -&gt;&gt; Cell: Creation des cellules\n  Config --&gt;&gt;Game: Set les valeurs pour game\n  Game -&gt;&gt; IRenderer: Subject.attach()\n  Game -&gt;&gt; FileHandler: Subject.attach()\n\n\n  Programme -&gt;&gt; Game: Game.run()\n  loop Pour chaque it\u00e9ration\n    Game -&gt;&gt; Grid: Grid.calculateNextGen()\n    loop Pour chaque cellule\n      Grid -&gt;&gt; IEvolutionStrategy: IEvolutionStrategy.update(Cell) \n    end\n    Game -&gt;&gt; Game: Subject.notify()\n    Game -&gt;&gt; FileHandler: FileHandler.saveGridToFile()\n    Game -&gt;&gt; IRenderer: IRenderer.update()\n    IRenderer --&gt;&gt; User: Montre la grille maj\n  end\n\n  Game --&gt;&gt; Programme: Terminer apr\u00e8s conditions atteintes (stabilit\u00e9 ou it\u00e9rations max)\n  Programme --&gt;&gt; User: Fin</code></pre> Illustre le flux d'ex\u00e9cution dans <code>Game::run()</code> : 1. Configuration via <code>Config::setup()</code> 2. Boucle principale dans <code>Game::run()</code> 3. Calcul d'\u00e9volution avec <code>Grid::calculateNextGen()</code> 4. Notification des observers via <code>Subject::notify()</code> 5. Rendu et sauvegarde via observers</p>"},{"location":"technique/diagrammes/#4-diagramme-dactivite","title":"4. Diagramme d'Activit\u00e9","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Initialisation\n    state Initialisation {\n        [*] --&gt; LancementProgramme\n        LancementProgramme --&gt; MessageBienvenue : \"Afficher un message de bienvenue\"\n        MessageBienvenue --&gt; ChargementOuCreation\n        state ChargementOuCreation {\n            [*] --&gt; ChargerFichier : \"Charger un fichier ?\"\n            ChargerFichier --&gt; DemanderNomFichier : \"Oui\"\n            DemanderNomFichier --&gt; GrilleDepuisFichier : \"Donner le nom du fichier\"\n            ChargerFichier --&gt; CreationNouvelleGrille : \"Non\"\n            CreationNouvelleGrille --&gt; DemanderTailleGrille : \"Donner la taille de la grille\"\n        }\n        GrilleDepuisFichier --&gt; ConfigObstacles\n        DemanderTailleGrille --&gt; ConfigObstacles\n        ConfigObstacles --&gt; DemanderToroidal : \"Ajouter des obstacles ?\"\n        DemanderToroidal --&gt; DemanderStrategie : \"Grille torique ?\"\n        DemanderStrategie --&gt; DemanderTypeRendu : \"Choisir strat\u00e9gie d'\u00e9volution\"\n        DemanderTypeRendu --&gt; DemanderNbIterations : \"Choisir type de rendu (console/graphique)\"\n        DemanderNbIterations --&gt; DemanderDelay : \"Entrer nombre d'it\u00e9rations\"\n        DemanderDelay --&gt; ModeAffichage\n    }\n    state ModeAffichage {\n        [*] --&gt; ModeConsole : \"Console ou graphique ?\"\n        ModeConsole --&gt; ConfigTopologie : \"Console\"\n        ModeConsole --&gt; ConfigTopologie : \"Graphique\"\n    }\n    ConfigTopologie --&gt; Simulation\n    state Simulation {\n        [*] --&gt; InitialisationSimulation : \"Initialiser Simulation\"\n        InitialisationSimulation --&gt; VerifierEtatGrille : \"gameIsRunning == True ?\"\n\n        state VerifierEtatGrille {\n            [*] --&gt; ArretSimulation : \"Grille stable\"\n            [*] --&gt; ArretSimulation : \"MAX it\u00e9rations atteint\"\n            [*] --&gt; IterationSuivante : \"Sinon, continuer\"\n        }\n\n        IterationSuivante --&gt; CalculEtatSuivant : \"Calculer \u00e9tat suivant de la grille\"\n        CalculEtatSuivant --&gt; Affichage : \"Afficher la grille\"\n        Affichage --&gt; VerifierEtatGrille : \"Recommencer\"\n        ArretSimulation --&gt; Fin\n    }\n    Fin --&gt; [*]</code></pre> <p>Repr\u00e9sente le workflow impl\u00e9ment\u00e9 dans <code>main()</code> et <code>Game::run()</code> : 1. Initialisation (<code>Game::setup()</code>) 2. Configuration des param\u00e8tres 3. Boucle d'\u00e9volution jusqu'\u00e0 :    * Grille stable (<code>Grid::isGridStable()</code>)    * Nombre max d'it\u00e9rations atteint 4. Sauvegarde finale (<code>FileHandler::saveGridToFile()</code>)</p>"},{"location":"technique/diagrammes/#diagrammes-techniques","title":"Diagrammes Techniques","text":""},{"location":"technique/diagrammes/#diagramme-de-classes","title":"Diagramme de Classes","text":""},{"location":"technique/diagrammes/#classes-principales","title":"Classes principales","text":"<ul> <li>Grid : Gestion de la grille de jeu</li> <li>Cell : Repr\u00e9sentation d'une cellule</li> <li>Game : Moteur du jeu</li> <li>Renderer : Interface d'affichage</li> <li>ConsoleRenderer</li> <li>SFMLRenderer</li> </ul>"},{"location":"technique/diagrammes/#strategies-devolution","title":"Strat\u00e9gies d'\u00e9volution","text":"<ul> <li>ClassicEvolution : </li> <li>R\u00e8gles standard de Conway</li> <li>Survie avec 2 ou 3 voisins</li> <li> <p>Naissance avec exactement 3 voisins</p> </li> <li> <p>HighLifeEvolution :</p> </li> <li>Variante avec r\u00e8gles \u00e9tendues</li> <li>Survie avec 2 ou 3 voisins</li> <li> <p>Naissance avec 3 ou 6 voisins</p> </li> <li> <p>Interface IEvolutionStrategy :</p> </li> <li>M\u00e9thode evolve() pour r\u00e8gles personnalis\u00e9es</li> <li>M\u00e9thode getName() pour identification</li> <li>Extension facile pour nouvelles r\u00e8gles</li> </ul>"},{"location":"technique/diagrammes/#diagramme-de-sequence","title":"Diagramme de s\u00e9quence","text":""},{"location":"technique/diagrammes/#flux-principal","title":"Flux principal","text":"<ol> <li>Initialisation du jeu</li> <li>Boucle de simulation</li> <li>Mise \u00e0 jour de l'affichage</li> <li>Gestion des \u00e9v\u00e9nements</li> </ol>"},{"location":"technique/diagrammes/#diagramme-dactivite","title":"Diagramme d'Activit\u00e9","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Initialisation\n    Initialisation --&gt; BoucleJeu\n\n    state BoucleJeu {\n        [*] --&gt; AttenteInput\n        AttenteInput --&gt; MiseAJourGrille : Input re\u00e7u\n        MiseAJourGrille --&gt; CalculGeneration\n        CalculGeneration --&gt; Rendu\n        Rendu --&gt; AttenteInput\n    }\n\n    BoucleJeu --&gt; [*] : Quitter</code></pre>"},{"location":"technique/diagrammes/#diagramme-de-cas-dutilisation","title":"Diagramme de Cas d'Utilisation","text":""},{"location":"technique/diagrammes/#architecture-mvc","title":"Architecture MVC","text":"<ul> <li>Mod\u00e8le : Grid, Cell</li> <li>Vue : Renderers</li> <li>Contr\u00f4leur : Game</li> </ul>"},{"location":"technique/diagrammes/#points-cles","title":"Points cl\u00e9s","text":"<ul> <li>S\u00e9paration claire des responsabilit\u00e9s</li> <li>Interfaces bien d\u00e9finies</li> <li>Extension facile (nouveaux renderers)</li> <li>Patterns de conception appliqu\u00e9s</li> </ul>"},{"location":"technique/diagrammes/#relations-entre-composants","title":"Relations entre composants","text":""},{"location":"technique/diagrammes/#hierarchie-des-classes","title":"Hi\u00e9rarchie des classes","text":"<ul> <li>Game : Contr\u00f4leur principal</li> <li>Grid : Gestion de l'\u00e9tat</li> <li>Cell : Unit\u00e9 de base</li> <li>Renderer : Interface d'affichage</li> <li>ConsoleRenderer</li> <li>SFMLRenderer</li> </ul>"},{"location":"technique/diagrammes/#flux-de-donnees","title":"Flux de donn\u00e9es","text":"<ol> <li>Input utilisateur \u2192 Game</li> <li>Game \u2192 Grid (\u00e9volution)</li> <li>Grid \u2192 Renderer (affichage)</li> <li>Renderer \u2192 Utilisateur (feedback)</li> </ol>"},{"location":"technique/diagrammes/#points-dextension","title":"Points d'extension","text":"<ul> <li>Nouveaux renderers</li> <li>R\u00e8gles personnalis\u00e9es</li> <li>Motifs additionnels</li> <li>Modes de simulation</li> </ul>"},{"location":"technique/tests/","title":"Tests du Jeu de la Vie","text":""},{"location":"technique/tests/#tests-unitaires-avec-google-test","title":"Tests Unitaires avec Google Test","text":""},{"location":"technique/tests/#1-tests-de-la-grille","title":"1. Tests de la Grille","text":"<p>Les tests de la classe <code>Grid</code> v\u00e9rifient : * Naissance des cellules (3 voisins vivants) * Mort des cellules (isolation ou surpopulation) * Gestion des bordures (mode toro\u00efdal/non-toro\u00efdal) * Stabilit\u00e9 de la grille</p> <p>R\u00e9f\u00e9rence : voir <code>GridTest.cpp</code> tests <code>CellBirth</code> et <code>CellDeath</code></p>"},{"location":"technique/tests/#2-tests-des-strategies-devolution","title":"2. Tests des Strat\u00e9gies d'\u00c9volution","text":"<p>Validation des r\u00e8gles : * <code>ClassicEvolution</code> : r\u00e8gles standard de Conway * <code>HighLifeEvolution</code> : r\u00e8gles modifi\u00e9es (naissance avec 6 voisins) * Cas limites et comportements sp\u00e9ciaux</p>"},{"location":"technique/tests/#3-tests-de-validation-des-entrees","title":"3. Tests de Validation des Entr\u00e9es","text":"<p>La classe <code>InputHandler</code> est test\u00e9e pour : * Validation des entr\u00e9es num\u00e9riques * Gestion des entr\u00e9es invalides * V\u00e9rification des bornes * Traitement des caract\u00e8res sp\u00e9ciaux</p>"},{"location":"technique/tests/#4-tests-de-fichiers","title":"4. Tests de Fichiers","text":"<p><code>FileHandler</code> est test\u00e9 pour : * Chargement de fichiers valides * Gestion des erreurs de format * Validation des dimensions * Sauvegarde correcte des \u00e9tats</p>"},{"location":"technique/tests/#5-methodologie","title":"5. M\u00e9thodologie","text":"<ul> <li>Tests automatis\u00e9s via CMake</li> <li>Assertions pour v\u00e9rifier les \u00e9tats attendus</li> <li>Fixtures pour la r\u00e9utilisation du code</li> <li>Mocks pour isoler les composants</li> </ul>"},{"location":"technique/tests/#6-couverture","title":"6. Couverture","text":"<ul> <li>Tests des cas normaux</li> <li>Tests des cas limites</li> <li>Tests des conditions d'erreur</li> <li>Validation des interfaces</li> </ul> <p>Les tests assurent la robustesse et la maintenance du code en v\u00e9rifiant automatiquement le comportement attendu de chaque composant.</p>"},{"location":"technique/architecture/extensibility/","title":"Extensibilit\u00e9 du Jeu de la Vie","text":""},{"location":"technique/architecture/extensibility/#1-pattern-strategy-pour-les-regles-devolution","title":"1. Pattern Strategy pour les R\u00e8gles d'\u00c9volution","text":"<p>L'architecture permet d'ajouter facilement de nouvelles r\u00e8gles d'\u00e9volution gr\u00e2ce \u00e0 l'interface <code>IEvolutionStrategy</code>. Pour cr\u00e9er une nouvelle r\u00e8gle : <pre><code>class NewEvolutionStrategy : public IEvolutionStrategy {\n    bool evolve(Cell* cell, int liveNeighbors) const override {\n        // Impl\u00e9menter les nouvelles r\u00e8gles ici\n    }\n};\n</code></pre></p>"},{"location":"technique/architecture/extensibility/#2-pattern-observer-pour-le-rendu","title":"2. Pattern Observer pour le Rendu","text":"<p>Le syst\u00e8me de rendu est extensible via l'interface <code>IRenderer</code>. Pour ajouter un nouveau type d'affichage : <pre><code>class NewRenderer : public IRenderer {\n    void render(Grid* grid) override {\n        // Impl\u00e9menter le nouveau rendu ici\n    }\n};\n</code></pre></p>"},{"location":"technique/architecture/extensibility/#3-gestion-des-fichiers-modulaire","title":"3. Gestion des Fichiers Modulaire","text":"<p>La classe <code>FileHandler</code> impl\u00e9mente l'interface <code>Observer</code>, permettant d'ajouter de nouveaux formats de sauvegarde : <pre><code>class NewFileFormat : public FileHandler {\n    void saveGridToFile(Grid* grid) override {\n        // Impl\u00e9menter le nouveau format ici\n    }\n};\n</code></pre></p>"},{"location":"technique/architecture/extensibility/#4-architecture-decouplee","title":"4. Architecture D\u00e9coupl\u00e9e","text":"<ul> <li>Injection de D\u00e9pendances : La classe <code>Game</code> accepte n'importe quelle impl\u00e9mentation des interfaces</li> <li>Communication par Events : Le pattern Observer permet d'ajouter de nouveaux observateurs sans modifier le code existant</li> <li>Configuration Flexible : La classe <code>Config</code> permet d'ajouter facilement de nouvelles options</li> </ul>"},{"location":"technique/architecture/extensibility/#5-points-dextension","title":"5. Points d'Extension","text":"<ol> <li>Nouvelles R\u00e8gles : Ajout de variantes du jeu</li> <li>Nouveaux Rendus : Support de diff\u00e9rents types d'affichage</li> <li>Nouveaux Formats : Support de diff\u00e9rents formats de fichier</li> <li>Nouvelles Fonctionnalit\u00e9s : Ajout facile via le syst\u00e8me d'observateurs</li> </ol>"},{"location":"technique/architecture/overview/","title":"Architecture du Jeu de la Vie","text":""},{"location":"technique/architecture/overview/#vue-densemble","title":"Vue d'Ensemble","text":"<p>Le projet suit une architecture orient\u00e9e objet avec une s\u00e9paration claire des responsabilit\u00e9s et l'utilisation de plusieurs design patterns.</p>"},{"location":"technique/architecture/overview/#design-patterns-implementes","title":"Design Patterns Impl\u00e9ment\u00e9s","text":""},{"location":"technique/architecture/overview/#1-pattern-observer","title":"1. Pattern Observer","text":"<ul> <li>Subject : La classe <code>Game</code> h\u00e9rite de <code>Subject</code></li> <li>Observers : <code>IRenderer</code> et <code>FileHandler</code> </li> <li>Permet la mise \u00e0 jour automatique des vues et la sauvegarde</li> <li>R\u00e9f\u00e9rence : voir <code>Game.hpp</code> lignes 11-46</li> </ul>"},{"location":"technique/architecture/overview/#2-pattern-strategy","title":"2. Pattern Strategy","text":"<ul> <li>Interface : <code>IEvolutionStrategy</code></li> <li>Impl\u00e9mentations : <code>ClassicEvolution</code> et <code>HighLifeEvolution</code></li> <li>Permet de changer les r\u00e8gles d'\u00e9volution dynamiquement</li> <li>R\u00e9f\u00e9rence : voir <code>IEvolutionStrategy.hpp</code> lignes 6-11</li> </ul>"},{"location":"technique/architecture/overview/#3-pattern-template-method","title":"3. Pattern Template Method","text":"<ul> <li>Utilis\u00e9 dans la classe <code>IRenderer</code></li> <li>M\u00e9thode commune <code>update()</code> pour tous les renderers</li> <li>Les sous-classes impl\u00e9mentent uniquement <code>render()</code></li> </ul>"},{"location":"technique/architecture/overview/#structure-des-composants","title":"Structure des Composants","text":""},{"location":"technique/architecture/overview/#core","title":"Core","text":"<ul> <li>Game : Contr\u00f4leur principal</li> <li>Grid : Mod\u00e8le de donn\u00e9es</li> <li>Cell : Entit\u00e9 de base</li> </ul>"},{"location":"technique/architecture/overview/#renderers","title":"Renderers","text":"<ul> <li>Interface <code>IRenderer</code></li> <li><code>ConsoleRenderer</code> : Affichage ASCII</li> <li><code>GraphicRenderer</code> : Interface SFML</li> </ul>"},{"location":"technique/architecture/overview/#gestion-des-fichiers","title":"Gestion des Fichiers","text":"<ul> <li><code>FileHandler</code> : Chargement/Sauvegarde</li> <li>Format texte standardis\u00e9</li> <li>Observateur des changements d'\u00e9tat</li> </ul>"},{"location":"technique/architecture/overview/#configuration","title":"Configuration","text":"<ul> <li><code>Config</code> : Gestion des param\u00e8tres</li> <li><code>InputHandler</code> : Validation des entr\u00e9es</li> <li>Template pour diff\u00e9rents types de donn\u00e9es</li> </ul>"},{"location":"technique/architecture/overview/#points-dextension","title":"Points d'Extension","text":"<ol> <li>Nouveaux renderers via <code>IRenderer</code></li> <li>Nouvelles r\u00e8gles via <code>IEvolutionStrategy</code></li> <li>Nouveaux formats via <code>FileHandler</code></li> <li>Nouveaux observateurs via <code>Observer</code></li> </ol>"},{"location":"technique/workflow/tools/","title":"Outils de D\u00e9veloppement et d'Impl\u00e9mentation","text":""},{"location":"technique/workflow/tools/#environnement-de-developpement","title":"Environnement de D\u00e9veloppement","text":"<ul> <li>IDE: Visual Studio Code</li> <li>Compilateur: GCC (MinGW64 pour Windows)</li> <li>Build System: CMake 3.10+</li> <li>Gestionnaire de Version: Git</li> </ul>"},{"location":"technique/workflow/tools/#bibliotheques-externes","title":"Biblioth\u00e8ques Externes","text":"<ul> <li>SFML 2.5.1</li> <li>Gestion des fen\u00eatres graphiques</li> <li>Rendu 2D</li> <li>Gestion des \u00e9v\u00e9nements</li> <li>Google Test</li> <li>Framework de tests unitaires</li> <li>Utilis\u00e9 pour les tests de la grille et des r\u00e8gles d'\u00e9volution</li> </ul>"},{"location":"technique/workflow/tools/#outils-de-build-et-deploiement","title":"Outils de Build et D\u00e9ploiement","text":"<ul> <li>CMake</li> <li>Configuration multi-plateforme</li> <li>Gestion des d\u00e9pendances</li> <li>G\u00e9n\u00e9ration des makefiles</li> <li>Make</li> <li>Compilation du projet</li> <li>Gestion des cibles de build</li> </ul>"},{"location":"technique/workflow/tools/#outils-de-debogage","title":"Outils de D\u00e9bogage","text":"<ul> <li>GDB</li> <li>D\u00e9bogage en ligne de commande</li> <li>Analyse des crashs</li> <li>VS Code Debugger</li> <li>Interface graphique de d\u00e9bogage</li> <li>Points d'arr\u00eat et inspection des variables</li> </ul>"},{"location":"technique/workflow/tools/#outils-de-qualite-de-code","title":"Outils de Qualit\u00e9 de Code","text":"<ul> <li>Clang-Format</li> <li>Formatage automatique du code</li> <li>Style coh\u00e9rent</li> <li>Clang-Tidy</li> <li>Analyse statique</li> <li>D\u00e9tection des probl\u00e8mes potentiels</li> </ul>"},{"location":"technique/workflow/tools/#documentation","title":"Documentation","text":"<ul> <li>Doxygen</li> <li>G\u00e9n\u00e9ration de la documentation</li> <li>Documentation des interfaces</li> <li>Markdown</li> <li>Documentation utilisateur</li> <li>README et guides</li> </ul>"},{"location":"technique/workflow/tools/#gestion-de-projet","title":"Gestion de Projet","text":"<ul> <li>Git</li> <li>Contr\u00f4le de version</li> <li>Branches pour les fonctionnalit\u00e9s</li> <li>GitHub</li> <li>H\u00e9bergement du code</li> <li>Issues et Pull Requests</li> </ul>"}]}