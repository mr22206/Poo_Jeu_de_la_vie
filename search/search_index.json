{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jeu de la Vie","text":""},{"location":"#presentation","title":"Pr\u00e9sentation","text":"<p>Le Jeu de la Vie est un automate cellulaire con\u00e7u par John Conway. Cette impl\u00e9mentation en C++ propose une version moderne et interactive du jeu.</p>"},{"location":"#fonctionnalites-principales","title":"Fonctionnalit\u00e9s principales","text":"<ul> <li>Mode console et mode graphique</li> <li>Grille torique optionnelle</li> <li>Cellules obstacles</li> <li>Motifs pr\u00e9-programm\u00e9s</li> <li>Traitement parall\u00e9lis\u00e9</li> </ul>"},{"location":"#demarrage-rapide","title":"D\u00e9marrage rapide","text":"<ol> <li>Installation</li> <li>Guide d'utilisation</li> <li>Documentation technique</li> </ol>"},{"location":"#architecture-du-projet","title":"Architecture du projet","text":"<p>Notre impl\u00e9mentation utilise les principes de la POO avec : - Pattern Observer pour la mise \u00e0 jour de l'interface - Pattern Strategy pour les r\u00e8gles d'\u00e9volution - Pattern State pour la gestion des \u00e9tats du jeu</p>"},{"location":"guide_utilisateur/installation/","title":"Installation","text":"<pre><code>git clone https://github.com/votre-repo/jeu-de-vie.git\ncd jeu-de-vie\n</code></pre> <pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre> <pre><code>./jeu-de-vie [chemin_fichier_configuration]\n</code></pre>"},{"location":"guide_utilisateur/installation/#guide-dutilisation","title":"Guide d'utilisation","text":""},{"location":"guide_utilisateur/installation/#modes-de-jeu","title":"Modes de jeu","text":"<ul> <li>Mode Console : Affichage dans le terminal</li> <li>Mode Graphique : Interface graphique SFML</li> </ul>"},{"location":"guide_utilisateur/installation/#commandes","title":"Commandes","text":"<ul> <li>Espace : Pause/Reprise</li> <li>R : R\u00e9initialiser la grille </li> <li>S : Sauvegarder l'\u00e9tat actuel</li> <li>L : Charger un motif pr\u00e9d\u00e9fini</li> <li>+/- : Ajuster la vitesse de simulation</li> </ul>"},{"location":"guide_utilisateur/installation/#format-des-fichiers-dentree","title":"Format des fichiers d'entr\u00e9e","text":""},{"location":"guide_utilisateur/installation/#architecture-du-projet","title":"Architecture du projet","text":""},{"location":"guide_utilisateur/installation/#vue-densemble","title":"Vue d'ensemble","text":"<p>Le projet utilise une architecture orient\u00e9e objet avec plusieurs patterns de conception :</p>"},{"location":"guide_utilisateur/installation/#patterns-de-conception-utilises","title":"Patterns de conception utilis\u00e9s","text":""},{"location":"guide_utilisateur/installation/#pattern-observer","title":"Pattern Observer","text":"<ul> <li>Subject : Grid</li> <li>Observers : ConsoleRenderer, GraphicRenderer</li> <li>Utilisation : Mise \u00e0 jour de l'interface</li> </ul>"},{"location":"guide_utilisateur/installation/#pattern-strategy","title":"Pattern Strategy","text":"<ul> <li>Interface : IEvolutionStrategy</li> <li>Impl\u00e9mentations : ClassicEvolution, HighLifeEvolution</li> <li>Utilisation : R\u00e8gles d'\u00e9volution des cellules</li> </ul>"},{"location":"guide_utilisateur/installation/#pattern-state","title":"Pattern State","text":"<ul> <li>Interface : GameState</li> <li>\u00c9tats : PlayState, PauseState</li> <li>Utilisation : Gestion des \u00e9tats du jeu</li> </ul>"},{"location":"guide_utilisateur/installation/#composants-principaux","title":"Composants principaux","text":"<ul> <li>Game : Contr\u00f4leur principal</li> <li>Grid : Gestion de la grille</li> <li>Cell : Repr\u00e9sentation d'une cellule</li> <li>Pattern : Gestion des motifs pr\u00e9d\u00e9finis</li> </ul>"},{"location":"guide_utilisateur/modes/","title":"Modes de jeu","text":""},{"location":"guide_utilisateur/modes/#mode-console","title":"Mode Console","text":""},{"location":"guide_utilisateur/modes/#presentation","title":"Pr\u00e9sentation","text":"<p>Le mode console permet une ex\u00e9cution l\u00e9g\u00e8re et rapide, id\u00e9ale pour : - Tests automatis\u00e9s - Ex\u00e9cution en arri\u00e8re-plan - Syst\u00e8mes sans interface graphique</p>"},{"location":"guide_utilisateur/modes/#utilisation","title":"Utilisation","text":""},{"location":"guide_utilisateur/modes/#options-disponibles","title":"Options disponibles","text":"<ul> <li><code>-n &lt;nombre&gt;</code> : Nombre d'it\u00e9rations</li> <li><code>-d &lt;d\u00e9lai&gt;</code> : D\u00e9lai entre les g\u00e9n\u00e9rations (ms)</li> <li><code>-o &lt;fichier&gt;</code> : Fichier de sortie</li> </ul>"},{"location":"guide_utilisateur/modes/#exemple-de-sortie-console","title":"Exemple de sortie console","text":""},{"location":"guide_utilisateur/utilisation/","title":"Guide d'utilisation","text":""},{"location":"guide_utilisateur/utilisation/#demarrage-du-jeu","title":"D\u00e9marrage du jeu","text":""},{"location":"guide_utilisateur/utilisation/#mode-console","title":"Mode Console","text":""},{"location":"guide_utilisateur/utilisation/#mode-graphique","title":"Mode Graphique","text":""},{"location":"guide_utilisateur/utilisation/#configuration-initiale","title":"Configuration initiale","text":""},{"location":"guide_utilisateur/utilisation/#format-du-fichier-de-configuration","title":"Format du fichier de configuration","text":""},{"location":"guide_utilisateur/utilisation/#controles","title":"Contr\u00f4les","text":""},{"location":"guide_utilisateur/utilisation/#mode-graphique_1","title":"Mode Graphique","text":"Touche Action Espace Pause/Reprise R R\u00e9initialiser S Sauvegarder L Charger motif +/- Vitesse \u00c9chap Quitter"},{"location":"guide_utilisateur/utilisation/#mode-console_1","title":"Mode Console","text":"Commande Action n G\u00e9n\u00e9ration suivante q Quitter s Sauvegarder"},{"location":"guide_utilisateur/utilisation/#motifs-predefinis","title":"Motifs pr\u00e9d\u00e9finis","text":""},{"location":"guide_utilisateur/utilisation/#insertion-de-motifs","title":"Insertion de motifs","text":"<ol> <li>Appuyez sur L pour entrer en mode insertion</li> <li>S\u00e9lectionnez un motif avec les touches 1-9</li> <li>Positionnez avec la souris</li> <li>Clic gauche pour placer</li> </ol>"},{"location":"guide_utilisateur/utilisation/#motifs-disponibles","title":"Motifs disponibles","text":"<ul> <li>1: Glider</li> <li>2: Blinker</li> <li>3: Block</li> <li>4: Beehive</li> <li>5: Pulsar</li> </ul>"},{"location":"guide_utilisateur/utilisation/#fonctionnalites-avancees","title":"Fonctionnalit\u00e9s avanc\u00e9es","text":""},{"location":"guide_utilisateur/utilisation/#grille-torique","title":"Grille torique","text":"<p>Activez l'option <code>-t</code> au lancement :</p> <pre><code>./jeu-de-vie -g -t config.txt\n</code></pre>"},{"location":"guide_utilisateur/utilisation/#cellules-obstacles","title":"Cellules obstacles","text":"<p>Dans le fichier de configuration : <pre><code>5 5         # Dimensions\n0 0 1 0 0   # Grille normale\n0 0 0 1 0\n0 1 X 1 0   # X = cellule obstacle\n0 0 0 0 0\n0 0 0 0 0\n</code></pre></p>"},{"location":"guide_utilisateur/utilisation/#sauvegardechargement","title":"Sauvegarde/Chargement","text":"<ul> <li>Les sauvegardes sont stock\u00e9es dans <code>./saves/</code></li> <li>Format : <code>save_YYYYMMDD_HHMMSS.txt</code></li> <li>Chargement : <code>./jeu-de-vie -l save_file.txt</code></li> </ul>"},{"location":"guide_utilisateur/utilisation/#depannage","title":"D\u00e9pannage","text":""},{"location":"guide_utilisateur/utilisation/#problemes-courants","title":"Probl\u00e8mes courants","text":"<ol> <li>Erreur SFML : V\u00e9rifiez l'installation de SFML</li> <li>Fichier invalide : V\u00e9rifiez le format du fichier</li> <li>Performance : R\u00e9duisez la taille de la grille</li> </ol>"},{"location":"guide_utilisateur/utilisation/#logs","title":"Logs","text":"<p>Les logs sont disponibles dans : - Linux : <code>~/.local/share/jeu-de-vie/logs/</code> - Windows : <code>%APPDATA%\\jeu-de-vie\\logs\\</code> ```</p> <p>Voulez-vous que je continue avec une autre section ou que je d\u00e9taille davantage une partie sp\u00e9cifique du guide d'utilisation ?</p>"},{"location":"technique/api/","title":"API","text":"<p>cpp class Game { public: // Constructeur avec fichier de configuration Game(const std::string&amp; configFile); // Contr\u00f4les principaux void run(); void pause(); void resume(); // Configuration void setRenderer(std::unique_ptr renderer); void setEvolutionStrategy(std::unique_ptr strategy); }; cpp class Grid : public Subject { public: Grid(int width, int height, bool toroidal = false); // Manipulation de la grille void update(); void setCellState(int x, int y, bool alive); bool getCellState(int x, int y) const; // Gestion des motifs void applyPattern(const Pattern&amp; pattern, const Position&amp; pos); }; cpp:docs/technique/api.md class IRenderer { public: virtual void render(const Grid&amp; grid) = 0; virtual void handleInput() = 0; }; class GraphicRenderer : public IRenderer { public: GraphicRenderer(int windowWidth, int windowHeight); void render(const Grid&amp; grid) override; }; cpp class IEvolutionStrategy { public: virtual bool evolve(const Cell&amp; cell, int liveNeighbors) = 0; }; class ClassicEvolution : public IEvolutionStrategy { public: bool evolve(const Cell&amp; cell, int liveNeighbors) override; }; cpp class Pattern { public: static Pattern Glider(); static Pattern Blinker(); static Pattern Block(); void rotate(int degrees); void flip(bool horizontal); }; cpp // Initialisation du jeu Game game(\"config.txt\"); game.setRenderer(std::make_unique(800, 600)); game.run(); cpp:docs/technique/api.md Grid grid(50, 50); auto glider = Pattern::Glider(); grid.applyPattern(glider, Position{10, 10}); cpp:docs/technique/api.md game.setEvolutionStrategy(std::make_uni"},{"location":"technique/architecture/","title":"Architecture Technique","text":""},{"location":"technique/architecture/#vue-densemble","title":"Vue d'ensemble","text":"<p>Notre impl\u00e9mentation du Jeu de la Vie suit une architecture orient\u00e9e objet avec une s\u00e9paration claire des responsabilit\u00e9s. Le syst\u00e8me est construit autour de plusieurs patterns de conception qui assurent sa modularit\u00e9 et son extensibilit\u00e9.</p>"},{"location":"technique/architecture/#composants-principaux","title":"Composants principaux","text":""},{"location":"technique/architecture/#1-noyau-du-jeu-core","title":"1. Noyau du jeu (Core)","text":"<ul> <li>Game : Contr\u00f4leur principal, orchestrant tous les composants</li> <li>Grid : Gestion de la grille et des r\u00e8gles d'\u00e9volution</li> <li>Cell : Repr\u00e9sentation d'une cellule et de son \u00e9tat</li> </ul>"},{"location":"technique/architecture/#2-systeme-de-rendu","title":"2. Syst\u00e8me de rendu","text":"<ul> <li>IRenderer : Interface abstraite pour le rendu</li> <li>ConsoleRenderer : Affichage en mode console</li> <li>GraphicRenderer : Affichage graphique via SFML</li> </ul>"},{"location":"technique/architecture/#3-gestion-des-etats","title":"3. Gestion des \u00e9tats","text":"<ul> <li>GameState : Interface des \u00e9tats du jeu</li> <li>PlayState : \u00c9tat en cours d'ex\u00e9cution</li> <li>PauseState : \u00c9tat en pause</li> </ul>"},{"location":"technique/architecture/#patterns-de-conception-utilises","title":"Patterns de conception utilis\u00e9s","text":""},{"location":"technique/architecture/#pattern-observer","title":"Pattern Observer","text":"<p>Utilis\u00e9 pour la mise \u00e0 jour de l'interface graphique :</p> <pre><code>Subject (Grid) ---&gt; Observer (IRenderer)\n                    \u251c\u2500\u2500 ConsoleRenderer\n                    \u2514\u2500\u2500 GraphicRenderer\n</code></pre>"},{"location":"technique/architecture/#pattern-strategy","title":"Pattern Strategy","text":"<p>Pour les r\u00e8gles d'\u00e9volution : <pre><code>IEvolutionStrategy ---&gt; ClassicEvolution\n                       HighLifeEvolution\n</code></pre></p>"},{"location":"technique/architecture/#pattern-state","title":"Pattern State","text":"<p>Pour la gestion des \u00e9tats du jeu : <pre><code>GameState ---&gt; PlayState\n              PauseState\n</code></pre></p>"},{"location":"technique/architecture/#flux-de-donnees","title":"Flux de donn\u00e9es","text":"<ol> <li>Chargement de la configuration</li> <li>Initialisation de la grille</li> <li>Boucle principale :</li> <li>Mise \u00e0 jour de l'\u00e9tat</li> <li>Calcul de la prochaine g\u00e9n\u00e9ration</li> <li>Notification des observateurs</li> <li>Rendu</li> </ol>"},{"location":"technique/architecture/#gestion-de-la-memoire","title":"Gestion de la m\u00e9moire","text":"<ul> <li>Utilisation de smart pointers</li> <li>RAII pour les ressources</li> <li>Pas d'allocation dynamique dans les boucles critiques</li> </ul>"},{"location":"technique/architecture/#performance","title":"Performance","text":""},{"location":"technique/architecture/#optimisations","title":"Optimisations","text":"<ul> <li>Mise en cache des voisins</li> <li>Parall\u00e9lisation des calculs</li> <li>Buffer double pour le rendu</li> </ul>"},{"location":"technique/architecture/#mesures","title":"Mesures","text":"<ul> <li>Temps de calcul &lt; 1ms pour une grille 100x100</li> <li>Utilisation m\u00e9moire &lt; 100MB</li> <li>60 FPS en mode graphique</li> </ul>"},{"location":"technique/architecture/#extensions-possibles","title":"Extensions possibles","text":"<ol> <li>Nouveaux renderers</li> <li>Rendu 3D</li> <li> <p>Export vers GIF</p> </li> <li> <p>R\u00e8gles personnalis\u00e9es</p> </li> <li>R\u00e8gles param\u00e9trables</li> <li> <p>Chargement dynamique</p> </li> <li> <p>Fonctionnalit\u00e9s avanc\u00e9es</p> </li> <li>Sauvegarde/Chargement</li> <li>Replay des parties</li> <li>Statistiques en temps r\u00e9el</li> </ol>"},{"location":"technique/diagrammes/","title":"Diagrammes","text":""},{"location":"technique/diagrammes/#diagramme-de-classes","title":"Diagramme de Classes","text":"<pre><code>classDiagram\n\n    class Game {\n        -Grid grid\n        -IRenderer* renderer\n        -GameState* currentState\n        -IEvolutionStrategy* evolutionStrategy\n        -float iterationDelay\n        -Game(string filename)\n        +run()\n        +setup()\n        +pause()\n        +resume()\n        +setRenderer(IRenderer* renderer)\n        +setState(GameState* state)\n        +setEvolutionStrategy(IEvolutionStrategy* strategy)\n    }\n\n    class GameState {\n        &lt;&lt;interface&gt;&gt;\n        #Game* game\n        +update()* void\n    }\n\n    class PlayState {\n\n        +update() void\n    }\n\n    class PauseState {\n\n        +update() void\n    }\n\n    class IEvolutionStrategy {\n        &lt;&lt;interface&gt;&gt;\n        +evolve(Cell* cell, int liveNeighbors)* bool\n    }\n\n    class ClassicEvolution {\n        +evolve(Cell* cell, int liveNeighbors) bool\n    }\n\n    class HighLifeEvolution {\n        +evolve(Cell* cell, int liveNeighbors) bool\n    }\n\n    class Subject {\n        &lt;&lt;interface&gt;&gt;\n        -List~Observer~ observers\n        +attach(Observer observer)\n        +detach(Observer observer)\n        +notify()\n    }\n    %%Renderers are not observers, the game observes the grid and then calls them when needed?\n    class Observer {\n        &lt;&lt;interface&gt;&gt;\n        +update(Subject subject)\n    }\n\n    class Grid {\n        -vector&lt;vector&lt;Cell&gt;&gt; cells\n        -int width\n        -int height\n        -bool isToroidal\n        +update()\n        +initCells() %%so foreach init state also. Use cell factory?\n        -calculateNextGeneration()\n        +applyPattern(Pattern pattern, Position pos)\n    }\n\n    class Cell { \n        -bool isAlive\n        -bool isObstacle\n        +Cell(Position pos)\n        +setState(CellState* state)\n        +update(int liveNeighbors)\n    }\n\n\n\n\n    class IRenderer {\n        &lt;&lt;interface (strategie?)&gt;&gt;\n        +render(Grid* grid)\n    }\n\n    %% strategie\n    class ConsoleRenderer {\n        +render(Grid* grid)\n        +update(Subject subject)\n    }\n\n    class GraphicRenderer {\n        -sf::RenderWindow window\n        +render(Grid* grid)\n        +update(Subject subject)\n    }\n\n    class FileHandler {\n        +static Grid loadGridFromFile(string filename)\n        +static void saveGridToFile(Grid grid, string filename)\n        +static Pattern loadPatternFromFile(string filename)\n        +static void savePatternToFile(Pattern pattern, string filename)\n    }\n\n    class Pattern {\n        -string name\n        -vector&lt;Position&gt; cells\n        +addCell(Position pos)\n        +removeCell(Position pos)\n        +clear()\n    }\n    class Statistics {\n        observes grid just like the renderers?\n    }\n\n    class Logger {\n        Uses file handler and is subscribed to the grid?\n    }\n    class Position {\n        x\n        y\n    }\n\n    %% Random cell factory is not needed because the state is defined in the array.\n    class CellFactory {\n\n    }\n    class FileCellFactory {\n\n    }\n    class RandomCellFactory {\n\n    }\n\n\n    Subject &lt;|-- Grid\n    Observer &lt;|-- ConsoleRenderer\n    Observer &lt;|-- GraphicRenderer\n\n    Game --&gt; Grid\n\n    Game --&gt; IRenderer\n    Game --&gt; GameState\n    Game --&gt; FileHandler\n    Game --&gt; IEvolutionStrategy\n\n    GameState &lt;|-- PlayState\n    GameState &lt;|-- PauseState\n    IEvolutionStrategy &lt;|-- ClassicEvolution\n    IEvolutionStrategy &lt;|-- HighLifeEvolution\n    Grid --&gt; Cell\n\n    IRenderer &lt;|-- ConsoleRenderer\n    IRenderer &lt;|-- GraphicRenderer\n\n\n    %% TODO: add a factory class for cells?\n    %% TODO: Jeu ou la grille en observable?\n    %% TODO: check si les methodes de cellstate sont suffisantes?\n\n    %% other observers to grid that we could add: AI or Rule Validation System\n    %% Triggers events based on specific grid patterns or thresholds, such as predefined goals (e.g., \"achieve 50 live cells\") or milestones (e.g., a specific glider appears).\n    %%  Sound System\n    %% Pattern Recognition and Highlighting</code></pre>"},{"location":"technique/diagrammes/#patterns-de-conception","title":"Patterns de Conception","text":""},{"location":"technique/diagrammes/#observer-pattern","title":"Observer Pattern","text":"<pre><code>classDiagram\n    class Subject {\n        +attach(Observer)\n        +detach(Observer)\n        +notify()\n    }\n    class Observer {\n        +update(Subject)\n    }\n    class Grid\n    class ConsoleRenderer\n    class GraphicRenderer\n\n    Subject &lt;|-- Grid\n    Observer &lt;|-- ConsoleRenderer\n    Observer &lt;|-- GraphicRenderer</code></pre>"},{"location":"technique/diagrammes/#strategy-pattern","title":"Strategy Pattern","text":"<pre><code>classDiagram\n    class IEvolutionStrategy {\n        +evolve(Cell, int)*\n    }\n    class ClassicEvolution {\n        +evolve(Cell, int)\n    }\n    class HighLifeEvolution {\n        +evolve(Cell, int)\n    }\n\n    IEvolutionStrategy &lt;|-- ClassicEvolution\n    IEvolutionStrategy &lt;|-- HighLifeEvolution</code></pre>"},{"location":"technique/diagrammes/#diagramme-de-sequence","title":"Diagramme de S\u00e9quence","text":"<pre><code>sequenceDiagram\n  participant User as User\n  participant Programme as Programme\n  participant Game as Game\n  participant Grid as Grid\n  participant Cell as Cell\n  participant FileHandler as FileHandler\n  User -&gt;&gt; Programme: Lancer le programme\n  Programme -&gt;&gt; Game: Instancie le singleton\n  Programme -&gt;&gt; Game: Game.setup() (demande des infos au user)\n  Game -&gt;&gt; User: Demande la config\n  User --&gt;&gt; Game: Entre la config\n  Game -&gt;&gt; Game: Init les propri\u00e9t\u00e9es de game avec les setter\n  alt User joue a partir d'une sauvegarde\n    Game -&gt;&gt; FileHandler: loadGridFromFile()\n    FileHandler --&gt;&gt; Game: return vector des 1 et 0\n    Game -&gt;&gt; Grid: Init grid\n    Game -&gt;&gt; Grid: Subscribe \n  end\n  alt User D\u00e9marre une nouvelle partie\n    Game -&gt;&gt; Grid: Init grid (avec vector de 1/0s random)\n    Game -&gt;&gt; Grid: Subscribe \n  end\n  Grid -&gt;&gt; Cell: init toutes les cellules\n  Cell -&gt;&gt; Grid: chaque cell subscribe a la grille \n  Game -&gt;&gt; IRenderer: Irenderer.update()\n  Programme -&gt;&gt; Game: Game.run()\n  loop Pour chaque it\u00e9ration\n    Game -&gt;&gt; Grid: Grid.calculateNextGen()\n    Grid -&gt;&gt; IEvolutionStrategy: update() modifie avec pointeurs (utilise un double buffer?)\n    Grid --&gt;&gt; Game: notify() peut \u00eatre notifier le renderer directement ?\n    Game -&gt;&gt; IRenderer: IRenderer.update()\n    IRenderer --&gt;&gt; User: shows updated grid\n    Game -&gt;&gt; FileHandler: FileHandler.saveGridToFile()\n  end\n  alt Mise en pause\n    User -&gt;&gt; Programme: Pause le jeu\n    Programme -&gt;&gt; Game: Game.pause()\n  end\n  alt Mise en jeu\n    User -&gt;&gt; Programme: Unpause le jeu\n    Programme -&gt;&gt; Game: Game.resume() qui notify le jeu a continuer d'iterer?\n  end\n  Game --&gt;&gt; Programme: Terminer apr\u00e8s conditions atteintes (stabilit\u00e9 ou it\u00e9rations max)\n  Programme --&gt;&gt; User: Fin</code></pre>"},{"location":"technique/diagrammes/#diagramme-dactivite","title":"Diagramme d'Activit\u00e9","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Initialisation\n    state Initialisation {\n        [*] --&gt; ChargementOuCreation\n        state ChargementOuCreation {\n            [*] --&gt; ChargerFichier : \"Charger un fichier ?\"\n            ChargerFichier --&gt; GrilleDepuisFichier : \"Oui\"\n            ChargerFichier --&gt; CreationNouvelleGrille : \"Non\"\n        }\n        GrilleDepuisFichier --&gt; ConfigObstacles\n        CreationNouvelleGrille --&gt; ConfigObstacles\n    }\n    ConfigObstacles --&gt; ModeAffichage : \"Ajouter des obstacles ?\"\n    state ModeAffichage {\n        [*] --&gt; ModeConsole : \"Console ou graphique ?\"\n        ModeConsole --&gt; ConfigTopologie : \"Console\"\n        ModeConsole --&gt; ConfigTopologie : \"Graphique\"\n    }\n    ConfigTopologie --&gt; Simulation : \"Grille torique ?\"\n    state Simulation {\n        [*] --&gt; Iteration : \"D\u00e9but boucle principale\"\n        Iteration --&gt; CalculEtatSuivant : \"Calculer \u00e9tat suivant\"\n        CalculEtatSuivant --&gt; NotificationObservateurs\n        NotificationObservateurs --&gt; Affichage\n        Affichage --&gt; Iteration : \"Prochaine it\u00e9ration\"\n        Iteration --&gt; Fin : \"Arr\u00eat (stabilisation ou limite atteinte)\"\n    }\n    Fin --&gt; [*]</code></pre>"},{"location":"technique/diagrammes/#notes-dimplementation","title":"Notes d'impl\u00e9mentation","text":""},{"location":"technique/diagrammes/#choix-techniques","title":"Choix techniques","text":"<ul> <li>Utilisation de SFML pour le rendu graphique</li> <li>Impl\u00e9mentation du pattern Observer pour la mise \u00e0 jour de l'interface</li> <li>Utilisation de Smart Pointers pour la gestion m\u00e9moire</li> <li>Grille torique impl\u00e9ment\u00e9e via modulo</li> </ul>"},{"location":"technique/diagrammes/#points-dextension","title":"Points d'extension","text":"<ul> <li>Support pour de nouvelles r\u00e8gles d'\u00e9volution</li> <li>Ajout de nouveaux renderers</li> <li>Syst\u00e8me de plugins pour les motifs</li> </ul>"},{"location":"tests/integration/","title":"Tests d'Int\u00e9gration","text":""},{"location":"tests/integration/#vue-densemble","title":"Vue d'ensemble","text":"<p>Les tests d'int\u00e9gration v\u00e9rifient l'interaction entre les diff\u00e9rents composants du syst\u00e8me.</p>"},{"location":"tests/integration/#scenarios-de-test","title":"Sc\u00e9narios de test","text":""},{"location":"tests/integration/#1-cycle-de-vie-complet","title":"1. Cycle de vie complet","text":"<ul> <li>Chargement d'une configuration</li> <li>Ex\u00e9cution de plusieurs g\u00e9n\u00e9rations</li> <li>V\u00e9rification de l'\u00e9tat final</li> <li>Sauvegarde des r\u00e9sultats</li> </ul>"},{"location":"tests/integration/#2-interface-graphique","title":"2. Interface graphique","text":"<ul> <li>Initialisation de la fen\u00eatre SFML</li> <li>R\u00e9ponse aux \u00e9v\u00e9nements utilisateur</li> <li>Synchronisation avec la logique du jeu</li> <li>Performance du rendu</li> </ul>"},{"location":"tests/integration/#3-patterns-et-evolution","title":"3. Patterns et \u00e9volution","text":"<p>Test des motifs classiques : - Oscillateurs (p\u00e9riode 2, 3, etc.) - Vaisseaux (gliders) - Structures stables</p>"},{"location":"tests/integration/#4-persistance-des-donnees","title":"4. Persistance des donn\u00e9es","text":"<ul> <li>Sauvegarde d'une partie en cours</li> <li>Chargement d'une partie sauvegard\u00e9e</li> <li>Validation de l'\u00e9tat restaur\u00e9</li> </ul>"},{"location":"tests/integration/#environnement-de-test","title":"Environnement de test","text":""},{"location":"tests/integration/#exemple-de-test-dintegration","title":"Exemple de test d'int\u00e9gration","text":""},{"location":"tests/integration/#metriques-de-qualite","title":"M\u00e9triques de qualit\u00e9","text":"<ul> <li>Temps d'ex\u00e9cution &lt; 100ms par g\u00e9n\u00e9ration</li> <li>Utilisation m\u00e9moire &lt; 500MB</li> <li>Taux de rafra\u00eechissement &gt; 30 FPS</li> </ul>"},{"location":"tests/unitaires/","title":"Tests Unitaires","text":""},{"location":"tests/unitaires/#vue-densemble","title":"Vue d'ensemble","text":"<p>Notre suite de tests unitaires utilise le framework Catch2 pour C++. Les tests couvrent les composants principaux du syst\u00e8me.</p>"},{"location":"tests/unitaires/#execution-des-tests","title":"Ex\u00e9cution des tests","text":"<pre><code>cd build\nctest --output-on-failure\n</code></pre>"},{"location":"tests/unitaires/#tests-par-composant","title":"Tests par composant","text":""},{"location":"tests/unitaires/#grid","title":"Grid","text":"<ul> <li>Test de cr\u00e9ation de grille</li> <li>Test des r\u00e8gles d'\u00e9volution</li> <li>Test de la grille torique</li> <li>Test des cellules obstacles</li> </ul>"},{"location":"tests/unitaires/#exemple-de-test","title":"Exemple de test","text":""},{"location":"tests/unitaires/#couverture-de-code","title":"Couverture de code","text":"<ul> <li>Couverture actuelle : 85%</li> <li>Objectif : 90%</li> <li>Points critiques couverts :</li> <li>R\u00e8gles d'\u00e9volution</li> <li>Gestion des bordures</li> <li>Chargement/Sauvegarde</li> </ul>"},{"location":"tests/unitaires/#validation-des-patterns","title":"Validation des patterns","text":"<p>Tests sp\u00e9cifiques pour les patterns pr\u00e9d\u00e9finis : - Glider - Blinker - Block - Beehive</p>"},{"location":"tests/unitaires/#tests-de-performance","title":"Tests de performance","text":"<ul> <li>Test de charge (grille 1000x1000)</li> <li>Test de performance du rendu</li> <li>Test de la parall\u00e9lisation</li> </ul>"},{"location":"tests/unitaires/#integration-continue","title":"Int\u00e9gration continue","text":"<p>Les tests sont ex\u00e9cut\u00e9s automatiquement : - \u00c0 chaque commit - Avant chaque merge request - Lors du d\u00e9ploiement</p>"}]}